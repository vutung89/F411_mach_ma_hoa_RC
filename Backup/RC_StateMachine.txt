/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body (Fixed with State Machine)
 ******************************************************************************
 * @attention
 * chuyen che do auto: dong thoi switch phai gai xuong duoi + nhan button A sang
 * chuyen che do ngat SBUS_OUT: nhan button B sang
 * auto_control_frame [10]= 0xAA + 0x55 + scaled_rc_channel[4](R-P-T-Y) + UAV_mode + RC_mode + crc16[2] (low + high)
 * request_channel_frame [40] = 0xAA + 0xAF + rc_channel_raw[18*2] + crc16 (low + high)
 *
 * UART config: set wordleght = 9bit (include parity bit), 2 stop bit
 * TX_SBUS_timer = 10 ms (dont use TX_SBUS_DMA)
 *
 ******************************************************************************
 */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include "crc.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

// ==================== SBUS STATE MACHINE DEFINITIONS ====================
typedef enum {
    SBUS_STATE_WAIT_HEADER,      // Đợi byte header 0x0F
    SBUS_STATE_RECEIVE_FRAME,    // Nhận 24 byte còn lại (đã có header)
    SBUS_STATE_VALIDATE_FRAME,   // Kiểm tra tính hợp lệ
    SBUS_STATE_PROCESS_FRAME,    // Xử lý dữ liệu
    SBUS_STATE_CHECK_NEXT_HEADER,// Kiểm tra header của frame tiếp theo
    SBUS_STATE_ERROR             // Trạng thái lỗi
} SBUS_RX_State_t;

typedef enum {
    USB_STATE_IDLE,              // Chờ dữ liệu
    USB_STATE_VALIDATE_HEADER,   // Kiểm tra header
    USB_STATE_VALIDATE_CRC,      // Kiểm tra CRC
    USB_STATE_PROCESS_AUTO,      // Xử lý auto control (0xAA 0x55)
    USB_STATE_PROCESS_REQUEST,   // Xử lý request channel (0xAA 0xAF)
    USB_STATE_ERROR              // Trạng thái lỗi
} USB_RX_State_t;

typedef enum {
    TX_STATE_IDLE,               // Không gửi
    TX_STATE_PREPARE,            // Chuẩn bị dữ liệu
    TX_STATE_SEND,               // Gửi dữ liệu
    TX_STATE_COMPLETE            // Hoàn thành
} TX_State_t;

// ==================== GLOBAL STATE VARIABLES ====================
SBUS_RX_State_t sbus_rx_state = SBUS_STATE_WAIT_HEADER;
USB_RX_State_t usb_rx_state = USB_STATE_IDLE;
TX_State_t tx_state = TX_STATE_IDLE;

#define UART_DEBUG		huart1

#define DISABLE_SBUS_OUT_ENABLE    	0x00
#define AUTONOMUOS_RC_ENABLE      	0x01

#define SBUS_FRAME_LENGTH    	25
#define SBUS_HEADER           	0x0F
#define SBUS_FOOTER           	0x00

#define SBUS_SIGNAL_OK          0x00
#define SBUS_SIGNAL_LOST        0x01
#define SBUS_SIGNAL_FAILSAFE    0x03

#define CHANNEL_COUNT			18
#define CHANNEL_MIN_VALUE		0
#define CHANNEL_MID_VALUE		992
#define CHANNEL_MAX_VALUE		2048

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */
/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
TIM_HandleTypeDef htim3;

UART_HandleTypeDef huart1;
UART_HandleTypeDef huart2;
UART_HandleTypeDef huart6;
DMA_HandleTypeDef hdma_usart1_tx;
DMA_HandleTypeDef hdma_usart1_rx;
DMA_HandleTypeDef hdma_usart6_rx;

/* USER CODE BEGIN PV */

// ==================== SBUS BUFFERS ====================
uint16_t failsafe_status;
uint16_t SBUS_footer;

// Double buffer để tránh race condition
uint8_t buf_rx[SBUS_FRAME_LENGTH];      // Buffer đang nhận DMA
uint8_t buf_process[SBUS_FRAME_LENGTH]; // Buffer để xử lý
uint8_t buf[SBUS_FRAME_LENGTH];         // Legacy buffer cho TX
uint16_t CH[CHANNEL_COUNT];

// ==================== USB UART BUFFERS ====================
uint8_t rx_usb_buf[10];
bool rx_usb_data_ok = false;
uint16_t rx_usb_cmp = 0;
uint16_t received_crc, calculated_crc;
uint8_t scaled_roll;
uint8_t scaled_throttle;
uint8_t scaled_pitch;
uint8_t scaled_yaw;
uint8_t UAV_Mode;
uint8_t RC_Mode;

// ==================== AUTONOMOUS CONTROL ====================
uint16_t CH_auto[4] = {CHANNEL_MID_VALUE, CHANNEL_MID_VALUE, CHANNEL_MID_VALUE, CHANNEL_MID_VALUE};
uint8_t pre_catch_buf[1] = {0x00};

// ==================== TX CONTROL ====================
bool tx_sbus_flag = false;
uint16_t tx_sbus_flag_count = 0;
uint16_t sbus_tx_cmp = 0;
uint8_t sbus_tx_buffer[SBUS_FRAME_LENGTH];

// ==================== STATUS FLAGS ====================
bool autonomous_status = false;
bool disable_sbus_out_status = false;
bool valid_sbusframe_status = false;

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_USART2_UART_Init(void);
static void MX_USART6_UART_Init(void);
static void MX_TIM3_Init(void);
static void MX_USART1_UART_Init(void);

/* USER CODE BEGIN PFP */

#ifdef UART_DEBUG
int _write(int file, char *pData, int len)
{
    HAL_StatusTypeDef status = HAL_UART_Transmit(&UART_DEBUG, (uint8_t*)pData, len, 100);
    if (status == HAL_OK) {
        return len;
    } else {
        return -1;
    }
}
#endif

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

// ==================== SBUS UTILITY FUNCTIONS ====================

void UpdateFailsafeStatus(uint8_t sbus_buf[SBUS_FRAME_LENGTH], uint16_t *failsafe_status)
{
    *failsafe_status = SBUS_SIGNAL_OK;
    if (sbus_buf[23] & (1 << 3))
        *failsafe_status = SBUS_SIGNAL_FAILSAFE;
    else if (sbus_buf[23] & (1 << 2))
        *failsafe_status = SBUS_SIGNAL_LOST;
    else
        *failsafe_status = SBUS_SIGNAL_OK;
}

void ClearFailsafeStatus(uint8_t sbus_buf[SBUS_FRAME_LENGTH])
{
    sbus_buf[23] &= ~(1 << 2); // Clear bit Lost
    sbus_buf[23] &= ~(1 << 3); // Clear bit Failsafe
}

bool IsAutonomousControl(uint16_t CH[CHANNEL_COUNT])
{
    if (0 < CH[5] && CH[5] < 600 && 1200 < CH[7] && CH[7] < 2000) {
        return true;
    }
    return false;
}

bool IsDisableSbusOut(uint16_t CH[CHANNEL_COUNT])
{
    if (1200 < CH[8] && CH[8] < 2000) {
        return true;
    }
    return false;
}

bool IsValidSbusFrame(const uint8_t sbus_buf[SBUS_FRAME_LENGTH])
{
    if (sbus_buf[0] != SBUS_HEADER || sbus_buf[24] != SBUS_FOOTER) {
        return false;
    }
    if ((sbus_buf[23] & 0xF0) != 0x00) {
        return false;
    }
    return true;
}

uint16_t cal_CH_auto_value(uint8_t scaled_value)
{
    uint32_t temp;
    temp = (scaled_value * (CHANNEL_MAX_VALUE - CHANNEL_MIN_VALUE)) / 255 + CHANNEL_MIN_VALUE;
    return (uint16_t)temp;
}

uint8_t cal_scaled_value(uint16_t CH)
{
    uint32_t temp;
    temp = (255 * (CH - CHANNEL_MIN_VALUE)) / (CHANNEL_MAX_VALUE - CHANNEL_MIN_VALUE);
    return (uint8_t)temp;
}

void ChannelToSbus(const uint16_t CH[CHANNEL_COUNT], uint8_t sbus[SBUS_FRAME_LENGTH])
{
    sbus[0] = SBUS_HEADER;

    sbus[1]  = (uint8_t)(CH[0] & 0xFF);
    sbus[2]  = (uint8_t)(((CH[0] >> 8) & 0x07) | ((CH[1] << 3) & 0xF8));
    sbus[3]  = (uint8_t)(((CH[1] >> 5) & 0x3F) | ((CH[2] << 6) & 0xC0));
    sbus[4]  = (uint8_t)((CH[2] >> 2) & 0xFF);
    sbus[5]  = (uint8_t)(((CH[2] >> 10) & 0x01) | ((CH[3] << 1) & 0xFE));
    sbus[6]  = (uint8_t)(((CH[3] >> 7) & 0x0F) | ((CH[4] << 4) & 0xF0));
    sbus[7]  = (uint8_t)(((CH[4] >> 4) & 0x7F) | ((CH[5] << 7) & 0x80));
    sbus[8]  = (uint8_t)((CH[5] >> 1) & 0xFF);
    sbus[9]  = (uint8_t)(((CH[5] >> 9) & 0x03) | ((CH[6] << 2) & 0xFC));
    sbus[10] = (uint8_t)(((CH[6] >> 6) & 0x1F) | ((CH[7] << 5) & 0xE0));
    sbus[11] = (uint8_t)((CH[7] >> 3) & 0xFF);
    sbus[12] = (uint8_t)(CH[8] & 0xFF);
    sbus[13] = (uint8_t)(((CH[8] >> 8) & 0x07) | ((CH[9] << 3) & 0xF8));
    sbus[14] = (uint8_t)(((CH[9] >> 5) & 0x3F) | ((CH[10] << 6) & 0xC0));
    sbus[15] = (uint8_t)((CH[10] >> 2) & 0xFF);
    sbus[16] = (uint8_t)(((CH[10] >> 10) & 0x01) | ((CH[11] << 1) & 0xFE));
    sbus[17] = (uint8_t)(((CH[11] >> 7) & 0x0F) | ((CH[12] << 4) & 0xF0));
    sbus[18] = (uint8_t)(((CH[12] >> 4) & 0x7F) | ((CH[13] << 7) & 0x80));
    sbus[19] = (uint8_t)((CH[13] >> 1) & 0xFF);
    sbus[20] = (uint8_t)(((CH[13] >> 9) & 0x03) | ((CH[14] << 2) & 0xFC));
    sbus[21] = (uint8_t)(((CH[14] >> 6) & 0x1F) | ((CH[15] << 5) & 0xE0));
    sbus[22] = (uint8_t)((CH[15] >> 3) & 0xFF);

    sbus[23] = 0x00;
    if (CH[16] == 1) sbus[23] |= (1 << 0);
    if (CH[17] == 1) sbus[23] |= (1 << 1);

    sbus[24] = SBUS_FOOTER;
}

void SbusToChannel(const uint8_t sbus[SBUS_FRAME_LENGTH], uint16_t CH[CHANNEL_COUNT])
{
    CH[0]  = (sbus[1] | (sbus[2] << 8)) & 0x07FF;
    CH[1]  = ((sbus[2] >> 3) | (sbus[3] << 5)) & 0x07FF;
    CH[2]  = ((sbus[3] >> 6) | (sbus[4] << 2) | (sbus[5] << 10)) & 0x07FF;
    CH[3]  = ((sbus[5] >> 1) | (sbus[6] << 7)) & 0x07FF;
    CH[4]  = ((sbus[6] >> 4) | (sbus[7] << 4)) & 0x07FF;
    CH[5]  = ((sbus[7] >> 7) | (sbus[8] << 1) | ((sbus[9] & 0x03) << 9)) & 0x07FF;
    CH[6]  = ((sbus[9] >> 2) | (sbus[10] << 6)) & 0x07FF;
    CH[7]  = ((sbus[10] >> 5) | (sbus[11] << 3)) & 0x07FF;
    CH[8]  = (sbus[12] | (sbus[13] << 8)) & 0x07FF;
    CH[9]  = ((sbus[13] >> 3) | (sbus[14] << 5)) & 0x07FF;
    CH[10] = ((sbus[14] >> 6) | (sbus[15] << 2) | (sbus[16] << 10)) & 0x07FF;
    CH[11] = ((sbus[16] >> 1) | (sbus[17] << 7)) & 0x07FF;
    CH[12] = ((sbus[17] >> 4) | (sbus[18] << 4)) & 0x07FF;
    CH[13] = ((sbus[18] >> 7) | (sbus[19] << 1) | (sbus[20] << 9)) & 0x07FF;
    CH[14] = ((sbus[20] >> 2) | (sbus[21] << 6)) & 0x07FF;
    CH[15] = ((sbus[21] >> 5) | (sbus[22] << 3)) & 0x07FF;
    CH[16] = (sbus[23] & (1 << 0)) ? 1 : 0;
    CH[17] = (sbus[23] & (1 << 1)) ? 1 : 0;
}

// ==================== STATE MACHINE HANDLERS ====================

void SBUS_RX_StateMachine(void)
{
    switch (sbus_rx_state) {

        case SBUS_STATE_WAIT_HEADER:
            if (pre_catch_buf[0] == SBUS_HEADER) {
                // Header hợp lệ, lưu vào buffer
                buf_rx[0] = SBUS_HEADER;
                sbus_rx_state = SBUS_STATE_RECEIVE_FRAME;

                // Nhận 24 bytes còn lại
                HAL_UART_AbortReceive(&huart6);
                HAL_UART_Receive_DMA(&huart6, &buf_rx[1], SBUS_FRAME_LENGTH - 1);
            } else {
                // Tiếp tục tìm header
                HAL_UART_Receive_DMA(&huart6, pre_catch_buf, 1);
            }
            break;

        case SBUS_STATE_RECEIVE_FRAME:
            // 24 bytes đã nhận xong, copy sang buffer xử lý
            memcpy(buf_process, buf_rx, SBUS_FRAME_LENGTH);
            sbus_rx_state = SBUS_STATE_VALIDATE_FRAME;
            break;

        case SBUS_STATE_VALIDATE_FRAME:
            if (IsValidSbusFrame(buf_process)) {
                valid_sbusframe_status = true;
                sbus_rx_state = SBUS_STATE_PROCESS_FRAME;
            } else {
                valid_sbusframe_status = false;
                printf("[SBUS WARN] Invalid frame detected\r\n");

                // Must restart DMA before transitioning to ERROR to avoid being stuck
                HAL_UART_AbortReceive(&huart6);
                memset(buf_rx, 0, sizeof(buf_rx));
                memset(pre_catch_buf, 0, sizeof(pre_catch_buf));
                HAL_UART_Receive_DMA(&huart6, pre_catch_buf, 1);

                sbus_rx_state = SBUS_STATE_WAIT_HEADER;
            }
            break;

        case SBUS_STATE_PROCESS_FRAME:
            // Xử lý frame hợp lệ
            SbusToChannel(buf_process, CH);
            memcpy(buf, buf_process, SBUS_FRAME_LENGTH);

            if (AUTONOMUOS_RC_ENABLE) {
                autonomous_status = IsAutonomousControl(CH);
            }

            if (DISABLE_SBUS_OUT_ENABLE) {
                disable_sbus_out_status = IsDisableSbusOut(CH);
            }

            UpdateFailsafeStatus(buf_process, &failsafe_status);

            // Kiểm tra byte tiếp theo có phải header không
            sbus_rx_state = SBUS_STATE_CHECK_NEXT_HEADER;
            HAL_UART_Receive_DMA(&huart6, pre_catch_buf, 1);
            break;

        case SBUS_STATE_CHECK_NEXT_HEADER:
            if (pre_catch_buf[0] == SBUS_HEADER) {
                // Vẫn đồng bộ tốt, tiếp tục nhận frame
                buf_rx[0] = SBUS_HEADER;
                sbus_rx_state = SBUS_STATE_RECEIVE_FRAME;
                HAL_UART_Receive_DMA(&huart6, &buf_rx[1], SBUS_FRAME_LENGTH - 1);
            } else {
                // Mất đồng bộ, tìm lại header
                printf("[SBUS WARN] Lost sync, byte=0x%02X, searching header\r\n", pre_catch_buf[0]);
                sbus_rx_state = SBUS_STATE_WAIT_HEADER;
                HAL_UART_Receive_DMA(&huart6, pre_catch_buf, 1);
            }
            break;

        case SBUS_STATE_ERROR:
            // This state should rarely be entered now, but keep as safety fallback
            printf("[SBUS ERROR] State machine in ERROR, forcing recovery\r\n");
            sbus_rx_state = SBUS_STATE_WAIT_HEADER;
            HAL_UART_AbortReceive(&huart6);
            memset(buf_rx, 0, sizeof(buf_rx));
            memset(buf_process, 0, sizeof(buf_process));
            memset(pre_catch_buf, 0, sizeof(pre_catch_buf));
            HAL_UART_Receive_DMA(&huart6, pre_catch_buf, 1);
            break;

        default:
            sbus_rx_state = SBUS_STATE_WAIT_HEADER;
            break;
    }
}

void USB_RX_StateMachine(void)
{
	if (!rx_usb_data_ok) return;

    switch (usb_rx_state) {

    	case USB_STATE_IDLE:
                if (rx_usb_buf[0] == 0xAA) {
                    usb_rx_state = USB_STATE_VALIDATE_HEADER;
                } else {
                    usb_rx_state = USB_STATE_ERROR;
                }
                break;

        case USB_STATE_VALIDATE_HEADER:
            if (rx_usb_buf[0] == 0xAA ) {
                usb_rx_state = USB_STATE_VALIDATE_CRC;
            } else {
                usb_rx_state = USB_STATE_ERROR;
            }
            break;

        case USB_STATE_VALIDATE_CRC:
            calculated_crc = calculate_crc16(rx_usb_buf, 8);
            received_crc = (rx_usb_buf[8] | (rx_usb_buf[9] << 8));

            if (calculated_crc == received_crc) {
                if (rx_usb_buf[1] == 0x55) {
                    usb_rx_state = USB_STATE_PROCESS_AUTO;
                } else if (rx_usb_buf[1] == 0xAF) {
                    usb_rx_state = USB_STATE_PROCESS_REQUEST;
                }
            } else {
                usb_rx_state = USB_STATE_ERROR;
            }
            break;

        case USB_STATE_PROCESS_AUTO:
            HAL_UART_Transmit(&huart2, rx_usb_buf, 10, 10);

            scaled_roll = rx_usb_buf[2];
            scaled_pitch = rx_usb_buf[3];
            scaled_throttle = rx_usb_buf[4];
            scaled_yaw = rx_usb_buf[5];
            UAV_Mode = rx_usb_buf[6];
            RC_Mode = rx_usb_buf[7];

            rx_usb_data_ok = true;
            rx_usb_cmp++;
            usb_rx_state = USB_STATE_IDLE;
            break;

        case USB_STATE_PROCESS_REQUEST:
            {
                uint8_t ch_buf[36];
                uint16_t crc_value;
                uint8_t output_buf[40];

                for (int i = 0; i < 18; i++) {
                    ch_buf[2*i] = (uint8_t)(CH[i] & 0xFF);
                    ch_buf[2*i+1] = (uint8_t)((CH[i] >> 8) & 0xFF);
                }

                crc_value = calculate_crc16(ch_buf, 36);

                output_buf[0] = 0xAA;
                output_buf[1] = 0xAF;
                memcpy(&output_buf[2], ch_buf, 36);
                output_buf[38] = (uint8_t)(crc_value & 0xFF);
                output_buf[39] = (uint8_t)((crc_value >> 8) & 0xFF);

                HAL_UART_Transmit(&huart2, output_buf, 40, 20);
            }
            usb_rx_state = USB_STATE_IDLE;
            break;

        case USB_STATE_ERROR:
            rx_usb_data_ok = false;
            usb_rx_state = USB_STATE_IDLE;
            break;

        default:
            usb_rx_state = USB_STATE_IDLE;
            break;
    }

    HAL_UART_Receive_IT(&huart2, rx_usb_buf, 10);
}

void SBUS_TX_StateMachine(void)
{
    switch (tx_state) {

        case TX_STATE_IDLE:
            if (tx_sbus_flag == true) {
                tx_state = TX_STATE_PREPARE;
            }
            break;

        case TX_STATE_PREPARE:
            memcpy(sbus_tx_buffer, buf, SBUS_FRAME_LENGTH);

            if (autonomous_status == true) {
                CH_auto[0] = cal_CH_auto_value(scaled_roll);
                CH_auto[1] = cal_CH_auto_value(scaled_pitch);
                CH_auto[2] = cal_CH_auto_value(scaled_throttle);
                CH_auto[3] = cal_CH_auto_value(scaled_yaw);

                sbus_tx_buffer[1] = (uint8_t)(CH_auto[0] & 0xFF);
                sbus_tx_buffer[2] = (uint8_t)((CH_auto[0] >> 8) & 0x07) |
                                    ((CH_auto[1] << 3) & 0xF8);
                sbus_tx_buffer[3] = (uint8_t)((CH_auto[1] >> 5) & 0x3F) |
                                    ((CH_auto[2] << 6) & 0xC0);
                sbus_tx_buffer[4] = (uint8_t)((CH_auto[2] >> 2) & 0xFF);
                sbus_tx_buffer[5] = (uint8_t)((CH_auto[2] >> 10) & 0x01) |
                                    ((CH_auto[3] << 1) & 0xFE);
                sbus_tx_buffer[6] = (uint8_t)((CH_auto[3] >> 7) & 0x0F) |
                                    ((CH[4] << 4) & 0xF0);
            }

            ClearFailsafeStatus(sbus_tx_buffer);
            tx_state = TX_STATE_SEND;
            break;

        case TX_STATE_SEND:
            if (disable_sbus_out_status == false) {
                HAL_UART_Transmit(&huart6, sbus_tx_buffer, SBUS_FRAME_LENGTH, 10);
                sbus_tx_cmp++;
            }
            tx_state = TX_STATE_COMPLETE;
            break;

        case TX_STATE_COMPLETE:
            HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_15);
            tx_sbus_flag = false;
            tx_state = TX_STATE_IDLE;
            break;

        default:
            tx_state = TX_STATE_IDLE;
            break;
    }
}

// ==================== CALLBACK FUNCTIONS ====================

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    if (htim->Instance == htim3.Instance) {
        tx_sbus_flag = true;
        tx_sbus_flag_count++;
    }
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == huart6.Instance) {
        SBUS_RX_StateMachine();
    }

    if (huart->Instance == huart2.Instance) {
        USB_RX_StateMachine();
    }
}

void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
     if (huart->Instance == huart6.Instance) {
         // Log error details for diagnosis
         uint32_t error = HAL_UART_GetError(huart);
         printf("[SBUS ERROR] Error code=0x%lX (", error);

         // Disable UART error interrupt temporarily to prevent cascading
         __HAL_UART_DISABLE_IT(&huart6, UART_IT_ERR);

         // Properly abort UART/DMA reception
         HAL_UART_AbortReceive(&huart6);

         // Reset state and buffers
         sbus_rx_state = SBUS_STATE_WAIT_HEADER;
         memset(buf_rx, 0, sizeof(buf_rx));
         memset(buf_process, 0, sizeof(buf_process));
         memset(pre_catch_buf, 0, sizeof(pre_catch_buf));

         // Small delay to ensure DMA is fully stopped
         for (volatile int i = 0; i < 1000; i++);

         // Re-enable UART error interrupt
         __HAL_UART_ENABLE_IT(&huart6, UART_IT_ERR);

         // Restart DMA reception
         HAL_StatusTypeDef status = HAL_UART_Receive_DMA(&huart6, pre_catch_buf, 1);
         if (status != HAL_OK) {
             printf("[SBUS ERROR] DMA restart failed, status=%d. Attempting force recovery...\r\n", status);
             // Force disable and enable DMA channel
             if (huart6.hdmarx != NULL) {
                 __HAL_DMA_DISABLE(huart6.hdmarx);
                 // Delay for DMA to fully disable
                 for (volatile int i = 0; i < 1000; i++);
                 // Try again
                 status = HAL_UART_Receive_DMA(&huart6, pre_catch_buf, 1);
                 if (status != HAL_OK) {
                     printf("[SBUS ERROR] Recovery attempt failed, status=%d\r\n", status);
                 }
             }
         }
     }

     if (huart->Instance == huart2.Instance) {
         uint32_t error = HAL_UART_GetError(huart);
         printf("[USB ERROR] Error code=0x%lX, restarting reception\r\n", error);

         // Disable UART error interrupt temporarily
         __HAL_UART_DISABLE_IT(&huart2, UART_IT_ERR);

         // Abort and reset
         HAL_UART_AbortReceive(&huart2);
         usb_rx_state = USB_STATE_IDLE;
         memset(rx_usb_buf, 0, sizeof(rx_usb_buf));

         // Small delay
         for (volatile int i = 0; i < 1000; i++);

         // Re-enable UART error interrupt and restart
         __HAL_UART_ENABLE_IT(&huart2, UART_IT_ERR);
         if (HAL_UART_Receive_IT(&huart2, rx_usb_buf, 10) != HAL_OK) {
             printf("[USB ERROR] Failed to restart reception\r\n");
         }
     }
}

/* USER CODE END 0 */
/**
 * @brief  The application entry point.
 * @retval int
 */

int main(void)
{
    HAL_Init();
    SystemClock_Config();

    MX_GPIO_Init();
    MX_DMA_Init();
    MX_USART2_UART_Init();
    MX_USART6_UART_Init();
    MX_TIM3_Init();
    MX_USART1_UART_Init();

    /* USER CODE BEGIN 2 */
    sbus_rx_state = SBUS_STATE_WAIT_HEADER;
    usb_rx_state = USB_STATE_IDLE;
    tx_state = TX_STATE_IDLE;

    // Start USB UART reception
    HAL_UART_Receive_IT(&huart2, rx_usb_buf, 10);

    // Start SBUS reception - tìm header
    if (HAL_UART_Receive_DMA(&huart6, pre_catch_buf, 1) != HAL_OK) {
        printf("[WARN] Failed to start SBUS DMA\r\n");
    }

    // Start TX timer (10ms period)
    HAL_TIM_Base_Start_IT(&htim3);

    printf("[INFO] System initialized\r\n");
    /* USER CODE END 2 */

    /* Infinite loop */
    /* USER CODE BEGIN WHILE */
    while (1)
    {
        // SBUS TX state machine
        if (tx_sbus_flag == true) {
            SBUS_TX_StateMachine();
        }

        /* USER CODE END WHILE */
        /* USER CODE BEGIN 3 */
    }
    /* USER CODE END 3 */
}

/**
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void)
{
	RCC_OscInitTypeDef RCC_OscInitStruct = {0};
	RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

	/** Configure the main internal regulator output voltage
	 */
	__HAL_RCC_PWR_CLK_ENABLE();
	__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

	/** Initializes the RCC Oscillators according to the specified parameters
	 * in the RCC_OscInitTypeDef structure.
	 */
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
	RCC_OscInitStruct.HSIState = RCC_HSI_ON;
	RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
	RCC_OscInitStruct.PLL.PLLM = 8;
	RCC_OscInitStruct.PLL.PLLN = 100;
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
	RCC_OscInitStruct.PLL.PLLQ = 4;
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
	{
		Error_Handler();
	}

	/** Initializes the CPU, AHB and APB buses clocks
	 */
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
			|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
	{
		Error_Handler();
	}
}

/**
 * @brief TIM3 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM3_Init(void)
{

	/* USER CODE BEGIN TIM3_Init 0 */

	/* USER CODE END TIM3_Init 0 */

	TIM_ClockConfigTypeDef sClockSourceConfig = {0};
	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM3_Init 1 */

	/* USER CODE END TIM3_Init 1 */
	htim3.Instance = TIM3;
	htim3.Init.Prescaler = 1000-1;
	htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim3.Init.Period = 1000-1;
	htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
	{
		Error_Handler();
	}
	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
	if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM3_Init 2 */

	/* USER CODE END TIM3_Init 2 */

}

/**
 * @brief USART1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_USART1_UART_Init(void)
{

	/* USER CODE BEGIN USART1_Init 0 */

	/* USER CODE END USART1_Init 0 */

	/* USER CODE BEGIN USART1_Init 1 */

	/* USER CODE END USART1_Init 1 */
	huart1.Instance = USART1;
	huart1.Init.BaudRate = 115200;
	huart1.Init.WordLength = UART_WORDLENGTH_8B;
	huart1.Init.StopBits = UART_STOPBITS_1;
	huart1.Init.Parity = UART_PARITY_NONE;
	huart1.Init.Mode = UART_MODE_TX_RX;
	huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
	huart1.Init.OverSampling = UART_OVERSAMPLING_16;
	if (HAL_UART_Init(&huart1) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN USART1_Init 2 */

	/* USER CODE END USART1_Init 2 */

}

/**
 * @brief USART2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_USART2_UART_Init(void)
{

	/* USER CODE BEGIN USART2_Init 0 */

	/* USER CODE END USART2_Init 0 */

	/* USER CODE BEGIN USART2_Init 1 */

	/* USER CODE END USART2_Init 1 */
	huart2.Instance = USART2;
	huart2.Init.BaudRate = 115200;
	huart2.Init.WordLength = UART_WORDLENGTH_8B;
	huart2.Init.StopBits = UART_STOPBITS_1;
	huart2.Init.Parity = UART_PARITY_NONE;
	huart2.Init.Mode = UART_MODE_TX_RX;
	huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
	huart2.Init.OverSampling = UART_OVERSAMPLING_16;
	if (HAL_UART_Init(&huart2) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN USART2_Init 2 */

	/* USER CODE END USART2_Init 2 */

}

/**
 * @brief USART6 Initialization Function
 * @param None
 * @retval None
 */
static void MX_USART6_UART_Init(void)
{

	/* USER CODE BEGIN USART6_Init 0 */

	/* USER CODE END USART6_Init 0 */

	/* USER CODE BEGIN USART6_Init 1 */

	/* USER CODE END USART6_Init 1 */
	huart6.Instance = USART6;
	huart6.Init.BaudRate = 100000;
	huart6.Init.WordLength = UART_WORDLENGTH_9B;
	huart6.Init.StopBits = UART_STOPBITS_2;
	huart6.Init.Parity = UART_PARITY_EVEN;
	huart6.Init.Mode = UART_MODE_TX_RX;
	huart6.Init.HwFlowCtl = UART_HWCONTROL_NONE;
	huart6.Init.OverSampling = UART_OVERSAMPLING_16;
	if (HAL_UART_Init(&huart6) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN USART6_Init 2 */

	/* USER CODE END USART6_Init 2 */

}

/**
 * Enable DMA controller clock
 */
static void MX_DMA_Init(void)
{

	/* DMA controller clock enable */
	__HAL_RCC_DMA2_CLK_ENABLE();

	/* DMA interrupt init */
	/* DMA2_Stream1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA2_Stream1_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(DMA2_Stream1_IRQn);
	/* DMA2_Stream2_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA2_Stream2_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(DMA2_Stream2_IRQn);
	/* DMA2_Stream7_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA2_Stream7_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(DMA2_Stream7_IRQn);

}

/**
 * @brief GPIO Initialization Function
 * @param None
 * @retval None
 */
static void MX_GPIO_Init(void)
{
	GPIO_InitTypeDef GPIO_InitStruct = {0};
	/* USER CODE BEGIN MX_GPIO_Init_1 */

	/* USER CODE END MX_GPIO_Init_1 */

	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOA_CLK_ENABLE();
	__HAL_RCC_GPIOB_CLK_ENABLE();

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_15, GPIO_PIN_RESET);

	/*Configure GPIO pin : PB15 */
	GPIO_InitStruct.Pin = GPIO_PIN_15;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	/* USER CODE BEGIN MX_GPIO_Init_2 */

	/* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void)
{
	/* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */
	__disable_irq();
	while (1)
	{
	}
	/* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
 * @brief  Reports the name of the source file and the source line number
 *         where the assert_param error has occurred.
 * @param  file: pointer to the source file name
 * @param  line: assert_param error line source number
 * @retval None
 */
void assert_failed(uint8_t *file, uint32_t line)
{
	/* USER CODE BEGIN 6 */
	/* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
	/* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
